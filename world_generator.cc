#include "world_generator.h"

//////////////////////////////////////////////////////////////////////////////////
// Static constant definitions for RegionFeatures:
//////////////////////////////////////////////////////////////////////////////////

const Vector3i
    RegionFeatures::TRILINEAR_BOX_SIZE( WorldGenerator::REGION_SIZE, TRILINEAR_BOX_HEIGHT, WorldGenerator::REGION_SIZE );

//////////////////////////////////////////////////////////////////////////////////
// Function definitions for RegionFeatures:
//////////////////////////////////////////////////////////////////////////////////

RegionFeatures::RegionFeatures(
    const uint64_t world_seed,
    const Vector2i& position,
    const BicubicPatchFeatures& fundamental_features,
    const BicubicPatchFeatures& octave_features
) :
    fundamental_patch_( world_seed, position, Vector2i( WorldGenerator::REGION_SIZE, WorldGenerator::REGION_SIZE ), fundamental_features )
{
    // TODO: Somehow move the ultimate seeds being used here into a different space
    //       than those used for the fundamental patch.  Otherwise, the corners shared
    //       by the fundamental and octave patches will have the same attributes (boring).
    //
    //       Right now this is done by XORing the world seed with a big random number
    //       that I smashed out of the keyboard.  I'm not sure if this is good...

    const Vector2i octave_size( BICUBIC_OCTAVE_EDGE, BICUBIC_OCTAVE_EDGE );
    const uint64_t octave_seed = world_seed ^ 0xfea873529eaf;
    octave_patches_[0][0] = BicubicPatch( octave_seed, position + Vector2i( 0, 0 ), octave_size, octave_features );
    octave_patches_[0][1] = BicubicPatch( octave_seed, position + Vector2i( 0, BICUBIC_OCTAVE_EDGE ), octave_size, octave_features );
    octave_patches_[1][0] = BicubicPatch( octave_seed, position + Vector2i( BICUBIC_OCTAVE_EDGE, 0 ), octave_size, octave_features );
    octave_patches_[1][1] = BicubicPatch( octave_seed, position + Vector2i( BICUBIC_OCTAVE_EDGE, BICUBIC_OCTAVE_EDGE ), octave_size, octave_features );

    // The geometry generated by slicing up a single TrilinearBox by value ranges tends to be sheet-like,
    // which is not ideal for cave networks.  However, by taking the intersection of a value range in two
    // TrilinearBoxes, the resulting geometry is very stringy and tunnel-like.

    boxes_[0] = TrilinearBox(
        world_seed,
        Vector3i( position[0], 0, position[1] ),
        TRILINEAR_BOX_SIZE,
        32
    );

    // TODO: The world seed is being modified here to make sure this box is not identical
    //       to the first one.  Is this a good way to do so?
    boxes_[1] = TrilinearBox(
        world_seed ^ 0x313535f3235,
        Vector3i( position[0], 0, position[1] ),
        TRILINEAR_BOX_SIZE,
        32
    );
}

//////////////////////////////////////////////////////////////////////////////////
// Function definitions for WorldGenerator:
//////////////////////////////////////////////////////////////////////////////////

WorldGenerator::WorldGenerator( const uint64_t world_seed ) :
    world_seed_( world_seed ) 
{
}

ChunkV WorldGenerator::generate_region( const Vector2i& position )
{
    // TODO: The region features here are static for now, but eventually they should be randomized
    //       depending on the position of the region itself.

    const BicubicPatchCornerFeatures fundamental_corner_features(
        Vector2f( 0.0f, 128.0f ),
        Vector2f( -64.0f, 64.0f ),
        Vector2f( -64.0f, 64.0f ),
        Vector2f( -64.0f, 64.0f )
    );

    const BicubicPatchFeatures fundamental_features(
        fundamental_corner_features,
        fundamental_corner_features,
        fundamental_corner_features,
        fundamental_corner_features
    );

    const BicubicPatchCornerFeatures octave_corner_features(
        Vector2f( 0.0f, 64.0f ),
        Vector2f( -64.0f, 64.0f ),
        Vector2f( -64.0f, 64.0f ),
        Vector2f( -64.0f, 64.0f )
    );

    const BicubicPatchFeatures octave_features(
        octave_corner_features,
        octave_corner_features,
        octave_corner_features,
        octave_corner_features
    );

    RegionFeatures region_features( world_seed_, position, fundamental_features, octave_features );
    ChunkV chunks;

    for ( int x = 0; x < CHUNKS_PER_REGION_EDGE; ++x )
    {
        for ( int z = 0; z < CHUNKS_PER_REGION_EDGE; ++z )
        {
            ChunkV column_chunks = generate_chunk_column( region_features, position, Vector2i( x, z ) );
            chunks.insert( chunks.end(), column_chunks.begin(), column_chunks.end() );
        }
    }

    return chunks;
}

ChunkV WorldGenerator::generate_chunk_column(
    const RegionFeatures& features,
    const Vector2i& region_position,
    const Vector2i& column_index
)
{
    ChunkV chunks;

    const Vector2i column_position = region_position + column_index * int( Chunk::CHUNK_SIZE );

    for ( int x = 0; x < Chunk::CHUNK_SIZE; ++x )
    {
        for ( int z = 0; z < Chunk::CHUNK_SIZE; ++z )
        {
            const Vector2i relative_position = column_index * int( Chunk::CHUNK_SIZE ) + Vector2i( x, z );

            const Scalar fundamental_height =
                features.get_fundamental_patch().interpolate( vector_cast<Scalar>( relative_position ) / Scalar( REGION_SIZE ) );

            const BicubicPatch octave_patch = features.get_octave_patch( relative_position / int( RegionFeatures::BICUBIC_OCTAVE_EDGE ) );

            const Vector2f octave_position(
                Scalar( relative_position[0] % RegionFeatures::BICUBIC_OCTAVE_EDGE ) / RegionFeatures::BICUBIC_OCTAVE_EDGE,
                Scalar( relative_position[1] % RegionFeatures::BICUBIC_OCTAVE_EDGE ) / RegionFeatures::BICUBIC_OCTAVE_EDGE
            );

            const Scalar
                octave_height = octave_patch.interpolate( octave_position ),
                total_height = fundamental_height + octave_height;

            const std::pair<BlockMaterial, Scalar> layers[] = 
            {
                std::make_pair( BLOCK_MATERIAL_MAGMA,   1.0f                             ),
                std::make_pair( BLOCK_MATERIAL_BEDROCK, 20.0f + ( total_height ) * 0.25f ),
                std::make_pair( BLOCK_MATERIAL_STONE,   52.0f + ( total_height ) * 1.00f ),
                std::make_pair( BLOCK_MATERIAL_CLAY,    58.0f + ( total_height ) * 1.00f ),
                std::make_pair( BLOCK_MATERIAL_DIRT,    62.0f + ( total_height ) * 1.00f ),
                std::make_pair( BLOCK_MATERIAL_GRASS,   63.0f + ( total_height ) * 1.00f )
            };

            const unsigned num_layers = sizeof( layers ) / sizeof( std::pair<Scalar, BlockMaterial> );
            unsigned bottom = 0;

            for ( unsigned i = 0; i < num_layers; ++i )
            {
                const BlockMaterial material = layers[i].first;
                const Scalar height = std::max( layers[i].second, Scalar( bottom + 1 ) );
                const unsigned top = unsigned( gmtl::Math::round( height ) );

                for ( unsigned y = bottom; y <= top; ++y )
                {
                    const unsigned chunk_index = y / Chunk::CHUNK_SIZE;

                    if ( chunk_index >= chunks.size() )
                    {
                        ChunkSP new_chunk( new Chunk( Vector3i( column_position[0], y, column_position[1] ) ) );
                        chunks.push_back( new_chunk );
                    }

                    ChunkSP chunk = chunks[chunk_index];

                    Block& block = chunk->get_block( Vector3i( x, y % Chunk::CHUNK_SIZE, z ) );

                    // TODO: Ensure that the components of this vector are clamped (or repeated) to [0.0,1.0].
                    const Vector3f box_position(
                        Scalar( relative_position[0] ) / Scalar( RegionFeatures::TRILINEAR_BOX_SIZE[0] ),
                        Scalar( y                    ) / Scalar( RegionFeatures::TRILINEAR_BOX_SIZE[1] ),
                        Scalar( relative_position[1] ) / Scalar( RegionFeatures::TRILINEAR_BOX_SIZE[2] )
                    );

                    if ( material != BLOCK_MATERIAL_MAGMA )
                    {
                        const Scalar
                            densityA = features.get_box( 0 ).interpolate( box_position ),
                            densityB = features.get_box( 1 ).interpolate( box_position );

                        if ( densityA > 0.45 && densityA < 0.55 && densityB > 0.45 && densityB < 0.55 )
                        {
                            block.set_material( BLOCK_MATERIAL_NONE );
                        }
                        else block.set_material( material );
                    }
                    else block.set_material( material );
                }

                bottom = top;
            }
        }
    }

    return chunks;
}
